# Ansible Global Inputs Flow

High Level:
The solution is to reduce variable inputs in different parts of sandbox. A large number of global inputs can be easily made available to all playbooks, with unique variables to each app defined on the app. This solution will involve both the ansible python package and 2G shell.

"Management Config" Flow in setup(for config that runs against read-only URL):
1. User sets global inputs
2. User sets inputs on apps, with the following reserved variables for defining a user playbook:
  - REPO_URL
  - REPO_USERNAME
  - REPO_PASSWORD
  - INVENTORY_GROUPS
3. PACKAGE DRIVER will cache app host data to sandbox data:
  - this is so sandbox service can later read this data (config params not available via api)
  - data json will be stored under the following key "ansible_<resource_name>"
  - if multiple hosts in list they will be reduced to one, only the matching host (for simplicity of design)
  - an api call will be needed to find the resource name on canvas matching the IP inside host list
4. PACKAGE DRIVER will read global inputs and merge with app level attributes
  - app level attributes will over-ride in case of conflict (if value populated)
5. Default config management will run


2G ad-hoc flow:
1. User populates script url and params like normal
2. when running playbook command the service will read sandbox data to find default config data with matching resource name key (if it exists)
3. params will be merged, any service level attributes over-riding the default app values (if values exist), playbook URL will be taken from cached as well, local service value over-rides.
4. playbook request is sent to driver, which will handle the global attribute merge step


Secondary User Config Flow In Setup:
1. Setup will read sandbox data for app configs, finding all the ansible prefixed keys
2. An admin 2G config service for each config is added to canvas with alias the same as deployed app resource
  - reserved keywords used to populate repo details on service
3. "Infrastructure command" is executed with target app name passed as target input:
  - no script params are needed to be populated, the shell will call sandbox data again and retrieve these params and handle merge as part of it's normal manual flow (some extra api calls, but will reuse code and  help to reduce setup script complexity)
4. If user playbook fails, the admin service remains on screen
